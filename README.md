SORTING ALGORITHMS
-------------------

What it is:
-------
They are algorithms that are in charge of giving an order to a set of data, they can be numbers or letters. In other words, a sorting algorithm will put the elements (numbers or letters) in order.
elements (numbers or letters) in order. The order is a given order, usually generated by an array

Example:
-------
[a, b, c, d] alphabetically ordered array.
[1, 2, 3, 4, 5] an array of integers in ascending order.

BUBBLE SORT
------------
![R](https://user-images.githubusercontent.com/98347450/173174361-b34e13c4-fe36-43f4-9815-1474475f07ac.gif)
It is the simplest algorithm that exists. It is so called because it selects adjacent elements, changes the number that is in the wrong position to the correct position.
the correct position. It is a slow and inefficient algorithm, two loops are needed (1 to go through the algorithm and the other to make the change, i.e., inside the second loop will be the number that is in the wrong position.
inside the second loop will be the condition that commands the algorithm), it also has many iterations (reciprocal action between two or more functions).
functions)


Cases
-----
Best Case: The best case occurs when the array is already sorted, and then only N comparisons are needed

Worst case: The worst case is when the array is reverse sorted, and the maximum number of comparisons and exchanges need to be performed

The average case: The average case is when the array is disordered but not so disordered that comparisons are needed but not so many

QUICKSORT
----------
The QUICK SORT algorithm is an efficient algorithm that is more complex than the previous algorithms. It uses the "divide and conquer" technique, it is a recursive algorithm. Basically, these three steps are involved in the whole process:

1- Pivot selection:You have to choose an element, which is going to be called pivot(usually the leftmost or rightmost element of the partition).

2- Splitting: Rearrange the array so that all the elements with values less than the pivot are before the pivot. Conversely, all elements with values greater than the pivot come after the pivot. Equal values can go in either direction. After this partition, the pivot is in its final position.

3- Repeat: Recursively apply the above steps to the subarray of elements with values smaller than the pivot and separately to the subarray of elements with values larger than the pivot.

![Quicksort](https://user-images.githubusercontent.com/98347450/173479554-2cd21110-e38b-46a1-ad0e-86d54140b05d.png)

COMPLEXITY
------------
The worst-case time complexity of Quicksort is O(n2), where n is the size of the input. The worst case occurs when the pivot is the smallest or largest element in the list or when all elements of the array are equal. This will result in the most unbalanced partition as the pivot splits the array into two subarrays of sizes 0 and n-1. If this happens repeatedly in each partition (say, we have a sorted array), then each recursive call processes a list of size one less than the previous list, resulting in O(n2) time.


------------------------------------------------------------------------------------------------------------------------------------------


SORTING ALGORITHMS
-------------------

Qué es:
-------
Son algoritmos que se encargan de dar un orden a un set de datos, peden ser numeros o letras. En otras palabras un algoritmo de ordenamiento va a poner los
elementos (numeros o letras) en orden. El orden es un orden dado, generalmente se genera por una array.

Ejemplo:
-------
[a, b, c, d] arreglo ordenado alfabéticamente.
[1, 2, 3, 4, 5] un arreglo de números enteros en orden ascendente.

BUBBLE SORT
------------
![R](https://user-images.githubusercontent.com/98347450/173174361-b34e13c4-fe36-43f4-9815-1474475f07ac.gif)
Es el algoritmo más simple que existe. Se llama asi porque va seleccionando los elementos adyacentes, cambia el numero que está en la posición incorrecta a
la posición correcta. Es un algoritmo lento y poco eficiente, se necesitan dos bucles (1 para recorrer el algoritmo y el otro para hacer el cambio, osea 
adentro del segundo bucle va a estar la condicion que ordene el algoritmo), también tiene muchas iteraciones (acción de modo recíproco entre dos o más 
funciones)

Casos
-------
El mejor caso: El mejor caso se da cuando la array ya está ordenada, y entonces sólo se necesitan N comparaciones

El peor caso: El peor caso se da cuando el array está ordenado de forma inversa, y hay que realizar el máximo número de comparaciones e intercambios

El caso medio: El caso medio se da cuando la array está desordenada pero no tanto, hay que hacer comparaciones pero no muchas

QUICKSORT
----------
El algoritmo de ordenado QUICK SORT, es un algoritmo eficiente es mas complejo que los algoritmos anteriores. Usa la tecnica de "divide y venceras", es un algoritmo recursivo.Basicamente, estos tres pasos están involucrados en todo el proceso:

1- Selección de pivot: Hay que elegir un elemento, el cual va a ser llamado pivote(generalmente el elemento más a la izquierda o más a la derecha de la partición).

2- Fraccionamiento: Reordenar el array de manera que todos los elementos con valores menores que el pivote estén antes del pivote. Por el contrario, todos los elementos con valores mayores que el pivote vienen después de este. Los valores iguales pueden ir en cualquier dirección. Después de esta partición, el pivote está en su posición final.

3- Repetirse: Aplique recursivamente los pasos anteriores al subarreglo de elementos con valores más pequeños que el pivote y por separado al subarreglo de elementos con valores mayores que el pivote.

![Quicksort](https://user-images.githubusercontent.com/98347450/173479554-2cd21110-e38b-46a1-ad0e-86d54140b05d.png)

COMPLEJIDAD
------------
La complejidad de tiempo en el peor de los casos de Quicksort es O(n2), dónde n es el tamaño de la entrada. El peor de los casos ocurre cuando el pivote es el elemento más pequeño o más grande de la lista o cuando todos los elementos de la matriz son iguales. Esto dará como resultado la partición más desequilibrada ya que el pivote divide la matriz en dos subarreglos de tamaños 0 y n-1. Si esto sucede repetidamente en cada partición (digamos, tenemos una matriz ordenada), entonces cada llamada recursiva procesa una lista de tamaño uno menos que la lista anterior, lo que da como resultado O(n2) tiempo.
